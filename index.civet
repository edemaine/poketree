{ SVG, type Svg, type G, type Line, type Text } from @svgdotjs/svg.js
{ urlFor, byName, toName } from ./pokedex.civet

xSpace .= 80
ySpace .= 100
nodeSize .= 100
animDelay .= 1000

class SpriteNode
  key: number?
  parent: SpriteNode?
  left: SpriteNode?
  right: SpriteNode?
  size: number?
  height: number?
  parentLine: Line
  heightText: Text?
  sizeText: Text?
  loaded: Promise<void>?

  x: number?
  y: number?
  tree: SpriteTree
  g: G

  @(@tree: SpriteTree, @parent?: SpriteNode, key?: number?)
    @g = @tree.nodeGroup.group()
    @parentLine = @tree.lineGroup.line()
    @setKey key
  computeHeight(): number
    @height =
      if @key?
        1 + Math.max @left!.computeHeight(), @right!.computeHeight()
      else
        -1
    @heightText?.plain @height.toString()
    @height
  computeSize(): number
    @size =
      if @key?
        @left!.computeSize() + 1 + @right!.computeSize()
      else
        0
    @sizeText?.plain @size.toString()
    @size
  skew(): number
    if @key?
      @right!.height! - @left!.height!
    else
      0
  inorder(): Generator<SpriteNode>
    return unless @key?
    yield* @left!.inorder()
    yield @
    yield* @right!.inorder()
  preorder(): Generator<SpriteNode>
    return unless @key?
    yield @
    yield* @left!.preorder()
    yield* @right!.preorder()
  postorder(): Generator<SpriteNode>
    return unless @key?
    yield* @left!.postorder()
    yield* @right!.postorder()
    yield @
  ancestors(): SpriteNode[]
    node: SpriteNode .= @
    while node.parent?
      node = node.parent!

  // Main node rendering
  setKey(@key: number?): void
    @g.clear()
    return unless @key?
    @size = 1
    @height = 0
    @g.opacity 1
    let loadComplete: =>
    @loaded = new Promise (loadComplete =)
    @g.image urlFor(@key), loadComplete!
    .size nodeSize, nodeSize
    .center 0, 0
    .add @g.element('title').words toName @key
    @loaded.then =>
      @g.plain @key!.toString()
      .attr 'x', 0
      .attr 'y', nodeSize/2
      .addClass 'key'
      @heightText = @g.plain (@height ?? 0).toString()
      .attr 'x', -nodeSize * 0.6
      .attr 'y', 0
      .addClass 'height'
      @sizeText = @g.plain (@size ?? 1).toString()
      .attr 'x', +nodeSize * 0.6
      .attr 'y', 0
      .addClass 'size'
    @updateParentLine()
  setParent(@parent: SpriteNode?): void
    @updateParentLine()
  updateParentLine(): void
    @parentLine.opacity 1
    if @parent?
      @parentLine.plot @x!, @y!, @parent.x!, @parent.y!
    else
      @parentLine.plot @x!, @y!, @x!, @y!
  addClass(className: string): void
    @g.addClass className
  removeClass(className: string): void
    @g.removeClass className

  // Call computeSize() before this
  layout(x: number, y: number): void
    return unless @key?
    @move x, y
    @updateParentLine()
    @left!.layout
      x - xSpace * (@left!.size! - (@left!.left?.size ?? 0))
      y + ySpace
    @right!.layout
      x + xSpace * (@right!.size! - (@right!.right?.size ?? 0))
      y + ySpace

  move(@x: number, @y: number)
    @g.transform
      translateX: @x
      translateY: @y
    @updateParentLine()
    @
  animMove(@x: number, @y: number, skipLine?: boolean): Promise<void>
    new Promise (done) =>
      @g.animate(animDelay).transform
        translateX: @x
        translateY: @y
      .during (t: number) =>
        if @parent? and not skipLine
          trans .= @g.transform()
          transParent .= @parent.g.transform()
          @parentLine.plot
            trans.translateX!, trans.translateY!
            transParent.translateX!, transParent.translateY!
      .after =>
        done()
  remove(): void
    @g.remove()
    @parentLine.remove()
  fadeOut(): Promise<void>
    new Promise (done) =>
      @parentLine.animate(animDelay)
      .opacity 0
      @g.animate(animDelay)
      .opacity 0
      .after =>
        @g.clear()
        @parentLine.plot 0, 0, 0, 0
        done()
  eject(newKey: number): SpriteNode
    key .= @key
    @setKey newKey
    new SpriteNode @tree, undefined, key
    .move @x!, @y!

class SpriteTree
  svg: Svg
  root: SpriteNode
  lineGroup: G
  nodeGroup: G

  @(@svg: Svg)
    @lineGroup .= @svg.group()
    .addClass 'lines'
    @nodeGroup .= @svg.group()
    .addClass 'nodes'
    @root = @newNode()
  newNode(parent?: SpriteNode, key?: number?)
    new SpriteNode @, parent, key
  clear(): void
    @lineGroup.clear()
    @nodeGroup.clear()
    @root = @newNode()
  empty(): boolean
    not @root.key?

  draw(anim?: boolean): Promise<void>
    // Draw nodes in postorder
    //for node of @root.postorder()
    //  @nodeGroup.add node.g
    @root.computeSize()
    @root.computeHeight()
    @root.layout @root.x ?? 0, @root.y ?? 0
    xMin .= @root.x! - (@root.left?.size ?? 0) * xSpace - nodeSize
    xMax .= @root.x! + (@root.right?.size ?? 0) * xSpace + nodeSize
    yMin .= @root.y! - nodeSize
    yMax .= @root.y! + (@root.height! + 1) * ySpace + nodeSize
    width .= xMax - xMin
    height .= yMax - yMin
    oldBox .= @svg.viewbox()
    if anim and not (xMin is oldBox.x and yMin is oldBox.y and width is oldBox.w and height is oldBox.h)
      new Promise (done) =>
        @root.g.animate animDelay
        .during (t: number) =>
          @svg.viewbox
            (1-t) * oldBox.x + t * xMin
            (1-t) * oldBox.y + t * yMin
            (1-t) * oldBox.w + t * width
            (1-t) * oldBox.h + t * height
        .after =>
          @svg.viewbox xMin, yMin, width, height
          done undefined
    else
      @svg.viewbox xMin, yMin, width, height
      Promise.resolve()

  find(key: number): SpriteNode
    node .= @root
    loop
      if not node.key? or key is node.key
        return node
      else if key < node.key
        node = node.left!
      else
        node = node.right!

  animFind(key: number): Promise<void>
    await @animInsert key, true
    return

  animInsert(key: number, find = false, del?: boolean): Promise<{node: SpriteNode, newNode?: SpriteNode}?>
    node .= @find key
    if @empty()
      unless find
        node.left = @newNode node
        node.right = @newNode node
        node.setKey key
        @draw()
      return

    newNode .= @newNode undefined, key
    newNode.addClass 'bad' if del
    newNode.move @root.x!, -nodeSize
    await newNode.loaded

    // animate move sprite to parent
    ancestors .= node.ancestors()
    ancestors.reverse()
    for ancestor of ancestors
      await newNode.animMove ancestor.x!, ancestor.y!

    if not node.key? // new key
      unless find
        node.left = @newNode node
        node.right = @newNode node
        node.move newNode.x!, newNode.y!
        node.setKey newNode.key
      parent := node.parent!
      newX .=
        if node is parent.left
          parent.x! - xSpace / 2
        else
          parent.x! + xSpace / 2
      newY .= parent.y! + ySpace
      if find
        await newNode.animMove newX, newY
        await newNode.fadeOut()
      else
        await.all [
          node.animMove newX, newY
          newNode.animMove newX, newY
          ...for n of @root.inorder() // animate make room for new node
            continue if n is node
            direction .= Math.sign n.key! - key
            n.animMove n.x! + direction * xSpace / 2, n.y!
        ]
        newNode.remove()
    else // replace
      await newNode.animMove node.x!, node.y!
      if del
        return {node, newNode}
      node.setKey key
      newNode.remove()
    await @draw not find
    return {node}

  animDelete(key: number): Promise<{node: SpriteNode}?>
    //unless {node, newNode} .= await @animInsert key, true, true
    return unless ref .= await @animInsert key, true, true
    {node, newNode} .= ref
    node.setKey undefined
    newNode = newNode!

    /*
    function swap(other: SpriteNode): void
      key .= node.key
      node.setKey other.key
      other.setKey key
      [node.x, other.x] = [other.x, node.x]
      [node.y, other.y] = [other.y, node.y]
    */

    loop // swap down until empty subtree
      node = node!
      start .= node.{x!,y!}
      if node.left?.key? // swap with predecessor
        pred: SpriteNode .= node.left
        await newNode.animMove pred.x!, pred.y!
        while pred.right?.key?
          pred = pred.right
          await newNode.animMove pred.x!, pred.y!
        /*
        predXY .= pred.{x!,y!}
        await pred.animMove start.x, start.y, true
        swap pred
        pred.{x,y} = predXY
        */
        eject .= pred.eject key
        await eject.animMove start.x, start.y
        node.setKey eject.key
        eject.remove()
        node = pred
      else if node.right?.key? // swap with successor
        succ: SpriteNode .= node.right
        await newNode.animMove succ.x!, succ.y!
        while succ.left?.key?
          succ = succ.left
          await newNode.animMove succ.x!, succ.y!
        eject .= succ.eject key
        await eject.animMove start.x, start.y
        node.setKey eject.key
        eject.remove()
        node = succ
      else // delete leaf
        await [
          node.fadeOut()
          newNode.fadeOut()
        ]
        node.left = node.right = undefined
        node.setKey undefined
        await.all
          for n of @root.inorder() // animate collapse space
            continue if n is node or n.key is key
            direction .= Math.sign n.x! - node.x!
            n.animMove n.x! - direction * xSpace / 2, n.y!
        await @draw true
        return {node}

  animRotate(key: number?, direction: 'left' | 'right'): Promise<void>
    return unless key?
    opposite: 'left' | 'right' .= 'left'
    if direction is 'left'
      opposite = 'right'
    else
      direction = 'right'
    node .= @find key
    return unless node.key?

    child .= node[opposite]
    unless child?.key?
      sign .= if direction is 'left' then 1 else -1
      await new Promise<void> (done) =>
        flash .= @svg.line node.x!, node.y!, node.x! + sign * xSpace, node.y! + ySpace
        .back()
        .addClass 'bad'
        flash.animate animDelay
        .opacity 0
        .after =>
          flash.remove()
          done()
      return

    unless node.parent?
      @root = child
    else
      if key < node.parent.key!
        node.parent.left = child
      else
        node.parent.right = child
      node.parentLine.animate animDelay
      .plot
        child.x!, node.y!
        node.parent.x!, node.parent.y!
    nodeY := node.y!
    child.parent = node.parent
    node[opposite] = child[direction]
    child[direction] = node
    node.parent = child
    child.parentLine.animate animDelay
    .plot
      child.x!, node.y!
      node.x!, child.y!
    node[opposite]!.parent = node
    if node[opposite]!.key?
      node[opposite]!.parentLine.animate animDelay
      .plot
        node[opposite]!.x!, node[opposite]!.y!
        node.x!, child!.y!
    await.all [
      node.animMove node.x!, child.y!, true
      child.animMove child.x!, nodeY, true
      ...for n of child[opposite]!.inorder()
        n.animMove n.x!, n.y! - ySpace
      ...for n of node[direction]!.inorder()
        n.animMove n.x!, n.y! + ySpace
    ]
    await @draw true
    return

  animAVL(key: number?): Promise<void>
    return unless key?
    node: SpriteNode? .= @find key
    @root.computeHeight()
    while node?.key?
      if Math.abs(node.skew()) > 1
        node.addClass 'bad'
        await new Promise (done) => setTimeout done, animDelay
        if node.skew() < -1
          if node.left!.skew() > 0
            await @animRotate node.left!.key, 'left'
          await @animRotate node.key, 'right'
        else if node.skew() > 1
          if node.right!.skew() < 0
            await @animRotate node.right!.key, 'right'
          await @animRotate node.key, 'left'
        node.removeClass 'bad'
      node = node.parent
    return

  animAVLInsert(key: number): Promise<void>
    result .= await @animInsert key
    return unless result?
    {node} .= result
    await @animAVL key

  animAVLDelete(key: number): Promise<void>
    result .= await @animDelete key
    return unless result?
    {node} .= result
    await @animAVL node.parent?.key

function gui(): void
  svg := SVG().addTo '#app'
  T := new SpriteTree svg
  if true
    T.root.setKey 15
    T.root.left = T.newNode T.root, 1
    T.root.left.left = T.newNode T.root.left
    T.root.left.right = T.newNode T.root.left, 7
    T.root.left.right.left = T.newNode T.root.left.right
    T.root.left.right.right = T.newNode T.root.left.right
    T.root.right = T.newNode T.root, 20
    T.root.right.left = T.newNode T.root.right
    T.root.right.right = T.newNode T.root.right
  T.draw()

  commandInput := document.querySelector('#command') as HTMLInputElement
  let submit: (e?: SubmitEvent) => void
  document.querySelector('form')!.addEventListener 'submit',
    submit = (e?: SubmitEvent) =>
      e?.preventDefault()
      execute commandInput.value

  for toggle of ['size', 'height']
    document.querySelector(`#${toggle}`)!.addEventListener 'input', (e) =>
      document.documentElement.classList.toggle toggle,
        (e.currentTarget as HTMLInputElement).checked

  function execute(commandString: string): void
    command .= commandString.split(/\s+/).filter &
    return unless command#
    command[0] = command[0].toLowerCase()
    if command[0] is 'clear'
      T.clear()
      T.draw()
      commandInput.value = command[1..].join ' '
      submit()
      return
    return if command# < 2
    let dex: number
    dex = parseInt command[1]
    if isNaN dex
      dex = byName command[1]
    if command# > 2
      commandInput.value = [command[0], ...command[2..]].join ' '
    else
      commandInput.value = ''
    switch command[0]
      when 'find', 'f'
        T.animFind dex
      when 'ins', 'add', 'insert', 'i', 'a'
        T.animInsert dex
      when 'del', 'rem', 'delete', 'remove', 'd'
        T.animDelete dex
      when 'l', 'rotl', 'rotatel'
        T.animRotate dex, 'left'
      when 'r', 'rotr', 'rotater'
        T.animRotate dex, 'right'
      when 'avl'
        T.animAVL dex
      when 'aa', 'ai', 'avladd', 'avlins'
        T.animAVLInsert dex
      when 'ad', 'avldel', 'avlrem'
        T.animAVLDelete dex
      else
        Promise.resolve()
    .then => submit()

window.addEventListener 'load', gui
